const std = @import("std");
const ck = @import("chunk.zig");

const Chunk = ck.Chunk;
const OpCode = ck.OpCode;

const Allocator = std.mem.Allocator;
const test_allocator = std.testing.allocator;

const InterpretResult = enum { Ok, CompileError, RuntimeError };

pub const VM = struct {
    chunk: *Chunk,
    // instruction pointer
    ip: usize,

    const Self = @This();

    pub fn init() Self {
        return .{
            .chunk = undefined,
            .ip = 0,
        };
    }

    pub fn deinit() void {
        // do something
    }

    pub fn interpret(self: *Self, chunk: *Chunk) InterpretResult {
        self.chunk = chunk;
        // TODO: create a bytecode iterator object that decodes bytecode into
        // individual instructions, and which we can use to both assert things
        // about the generated bytecode, format it, interpret it, etc, etc.
        const instruction = self.chunk.code.items[self.ip];
        const op_code = @intToEnum(OpCode, instruction);

        switch (op_code) {
            .Return => {
                return InterpretResult.Ok;
            },
            else => {
                std.log.err("unhandled opcode {s}", .{op_code});
                return InterpretResult.Ok;
            },
        }

        self.ip += 1;
    }
};

test "vm can execute code" {
    var chunk = Chunk.init(test_allocator);
    defer chunk.deinit();

    try chunk.write_constant(1.2, 123);
    try chunk.write_opcode(OpCode.Return, 123);

    var vm = VM.init();
    const result = vm.interpret(&chunk);

    try std.testing.expectEqual(result, InterpretResult.Ok);
}
